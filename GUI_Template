package petris;

import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.layout.GridPane;
import javafx.scene.text.Text;

public class GUI{
    //create the 5 positions that represent the coordinates of the falling pentomino
    private Rectangle position1 = new Rectangle(50, 50);
    private Rectangle position2 = new Rectangle(50, 50);
    private Rectangle position3 = new Rectangle(50, 50);
    private Rectangle position4 = new Rectangle(50, 50);
    private Rectangle position5 = new Rectangle(50, 50);
    
    //create the two text files that contain rowscleared and currentscore
    private Text rowscleared;
    private Text currentscore;
    
    //create Pane board, which is only the board where the game happens
    private Pane board = new Pane();
    
    BackendGrid backendGrid;
    
    public GUI(BackendGrid backendGrid){
        //use the same BackendGrid from Main from GameCycle
        this.backendGrid = backendGrid;
        
    }
    public GridPane createGUI(){
        //create a mainGrid where we add:
        
        GridPane mainGrid = new GridPane();
        
        mainGrid.setMinSize(600,500);
        mainGrid.setPadding(new Insets(0, 0, 10, 20));
        mainGrid.setVgap(5); 
        mainGrid.setHgap(5);
        //here we add the left rectangle containing scores and rules
        mainGrid.add(scoresRule(), 0, 0);
        //middle rectangle with gameBoard
        mainGrid.add(setBackground(), 1, 0);
        //right rectangle where nextPentomino is displayed
        mainGrid.add(nextPentomino(), 2, 0);
        mainGrid.getStylesheets().add("petris/stylesheet.css");
        
        return mainGrid;
    } 
    public Parent scoresRule(){
        //creates the grid for scores and rules
        GridPane scoresRule = new GridPane();
        scoresRule.setMinSize(125, 730);
        scoresRule.setPadding(new Insets(0, 0, 0, 0));
        scoresRule.setHgap(5);
        scoresRule.setGridLinesVisible(false);
        //adds scores on the top
        scoresRule.add(score(), 0, 0);
        //adds rules on the bottom
        scoresRule.add(rules(), 0, 1);
        return scoresRule;
    }
    public Parent score(){
        //create score gridpane
        GridPane score = new GridPane();
        score.setMinSize(125, 375);
        score.setPadding(new Insets(0, 0, 0, 0));
        score.setGridLinesVisible(false);
        score.setStyle("-fx-border-color: white; -fx-background-color: #9ac6d6; -fx-fill: #DAA520; fx-font-weight: bold; -fx-font-size: 11pt");
        
        Text RowsCleared = new Text(200, 200,  "Rows cleared:");
        RowsCleared.setStyle("-fx-font-size: 12pt; -fx-font-color:red;");
        score.setAlignment(Pos.TOP_CENTER);
        rowscleared = new Text(backendGrid.getRowsCleared() + "");
        rowscleared.setStyle("-fx-fill: #DAA520; -fx-font-size: 11pt;");
        Text Currentscore = new Text("Current score");
        Currentscore.setStyle("-fx-font-size: 12pt; -fx-font-color:red;");
        currentscore = new Text(backendGrid.getScore() + "");
        score.add(RowsCleared, 0, 0);
        score.add(rowscleared, 0, 1);
        score.add(Currentscore, 0, 2);
        score.add(currentscore, 0, 3);
        
        return score;
    }
    public void updateData(){
        //whenever this method is called it will change the rowscleared and currentscore with the latest values taken from BackendGrid
        rowscleared.setText(backendGrid.getRowsCleared()+ "");
        currentscore.setText(backendGrid.getScore()+ "");
    }
    public Parent rules(){
        //gridpane rules
        GridPane rules = new GridPane();
        rules.setMinSize(125, 375);
        rules.setGridLinesVisible(false);
        rules.setAlignment(Pos.TOP_LEFT);
        rules.setStyle("-fx-border-color: white; -fx-border-width: 0 1 1 1; -fx-background-color: #9ac6d6; -fx-fill: #DAA520; fx-font-weight: bold;");
        Text controlsHeader = new Text("Controls");
        controlsHeader.setStyle("-fx-fill: red; -fx-font-size: 12pt");
        Text controls = new Text("Movement: \nleft and right \narrow keys \nRotation: \nup and down \narrow keys \nDrop piece:\nspacebar \n");
        Text rulesHeader = new Text("Rules");
        rulesHeader.setStyle("-fx-fill: red; -fx-font-size: 12pt");
        Text rule = new Text("Earn score by \nclearing lines\nwhen the board \nfills up\nyou lose.\n1 line:  100\n2 lines: 300\n3 lines: 600 \n4 lines: 1000\n5 lines: 1500 ");
        
        rules.add(controlsHeader, 0,1);
        rules.add(controls, 0, 2);
        rules.add(rulesHeader, 0 ,3);
        rules.add(rule, 0, 4);
        
        return rules;
    }
    
    public Parent nextPentomino(){
        //you get the idea already...
        GridPane nextPentomino = new GridPane();
        nextPentomino.setMinSize(200, 750);
        nextPentomino.setPadding(new Insets(20, 0, 0, 20));
       
        //nextPentomino.setStyle("-fx-border-color: white; -fx-background-color: #9ac6d6; -fx-fill: #DAA520; fx-font-weight: bold;");
        nextPentomino.setGridLinesVisible(true);
        Text pentomino = new Text("Next pentomino");
        pentomino.setText("Next pentomino");
       
        nextPentomino.add(pentomino, 0, 0);
        return nextPentomino;
    }
    
    public Parent setBackground(){
        //set the initial background, that is going to be constantly updated
        board.setMinSize(250, 750);
        
        int count = 0;
        int[][] grid = backendGrid.getGrid();
        //fill board with rectangles representing each coordinate of gridMatrix from BackendGrid
        for(int i = 0; i < grid.length ; i++){
            for(int x = 0; x < grid[0].length; x++){
                    Rectangle rec = new Rectangle(50, 50);
                    //set the color adn other things
                    rec.setFill(Color.LAVENDER);
                    rec.setStroke(Color.BLACK);
                    rec.setTranslateX(x * 50);
                    rec.setTranslateY(i * 50);
                    board.getChildren().add(count, rec);
                    count++;
            }
        }
        //add the rectangles representing the falling pentomino to the board 
        //we do this after creating the background so that position1, position2... are in front of it
        
        position1.setStroke(Color.BLACK);
        position2.setStroke(Color.BLACK);
        position3.setStroke(Color.BLACK);
        position4.setStroke(Color.BLACK);
        position5.setStroke(Color.BLACK);
        
        board.getChildren().add(position1);
        board.getChildren().add(position2);
        board.getChildren().add(position3);
        board.getChildren().add(position4);
        board.getChildren().add(position5);
        
        return board;
    }
    
    public void updatePentomino(){
        //updates the rectangles color and position
        //if the game is over the falling pento will be removed from board to avoid bugs
        if(backendGrid.gameOverCheck()){
            board.getChildren().remove(position1);
            board.getChildren().remove(position2);
            board.getChildren().remove(position3);
            board.getChildren().remove(position4);
            board.getChildren().remove(position5);
        }
        
        int[][] coordinates =  backendGrid.getFallingBlock().getCoordinates();
        Color color = null;
        switch(backendGrid.getFallingBlock().getColorIndex()){
                    case 1: color = Color.SEAGREEN; break;
                    case 2: color = Color.CORAL; break;
                    case 3: color = Color.SKYBLUE; break;
                    case 4: color = Color.INDIGO; break;
                    case 5: color = Color.YELLOW; break;
                    case 6: color = Color.PERU; break;
                    case 7: color = Color.LIGHTGRAY; break;
                    case 8: color = Color.AQUA; break;
                    case 9: color = Color.YELLOWGREEN; break;
                    case 10: color = Color.ROSYBROWN; break;
                    case 11: color = Color.SIENNA; break;
                    case 12: color = Color.RED; break;
        }
        position1.setFill(color);
        position2.setFill(color);
        position3.setFill(color);
        position4.setFill(color);
        position5.setFill(color);
        
        position1.setTranslateY(coordinates[1][0]*50);
        position1.setTranslateX(coordinates[0][0]*50);
        position2.setTranslateY(coordinates[1][1]*50);
        position2.setTranslateX(coordinates[0][1]*50);
        position3.setTranslateY(coordinates[1][2]*50);
        position3.setTranslateX(coordinates[0][2]*50);
        position4.setTranslateY(coordinates[1][3]*50);
        position4.setTranslateX(coordinates[0][3]*50);
        position5.setTranslateY(coordinates[1][4]*50);
        position5.setTranslateX(coordinates[0][4]*50);
        
    }
    public void updateGameBoard(){
        //goes through each coordinate of gridMatrix from backendGrid and creates a new rectangle with the colorindex the gridMatrix returns
            int count = 0;
            int[][] grid = backendGrid.getGrid();
            for(int i = 0; i < grid.length ; i++){
                for(int x = 0; x < grid[0].length; x++){
                    Rectangle rec = new Rectangle(50, 50);
                    rec.setTranslateX(x * 50);
                    rec.setTranslateY(i * 50);
                    board.getChildren().set(count, rec);
                    rec.setStroke(Color.BLACK);

                    switch(grid[i][x]){
                        case 0: rec.setFill(Color.LAVENDER); break;
                        case 1: rec.setFill(Color.SEAGREEN); break;
                        case 2: rec.setFill(Color.CORAL); break;
                        case 3: rec.setFill(Color.SKYBLUE); break;
                        case 4: rec.setFill(Color.INDIGO); break;
                        case 5: rec.setFill(Color.YELLOW); break;
                        case 6: rec.setFill(Color.PERU); break;
                        case 7: rec.setFill(Color.LIGHTGRAY); break;
                        case 8: rec.setFill(Color.AQUA); break;
                        case 9: rec.setFill(Color.YELLOWGREEN); break;
                        case 10: rec.setFill(Color.ROSYBROWN); break;
                        case 11: rec.setFill(Color.SIENNA); break;
                        case 12: rec.setFill(Color.RED); break;

                    }
                    count++;
                }
            }   
    }
    public Scene getScene(){
        //adds the controls to the scene and creates the scene
        Controlls controls = new Controlls(backendGrid);
        EventHandler eventHandler = controls.setControls();
        Scene scene = new Scene(createGUI());
        scene.addEventFilter(KeyEvent.KEY_PRESSED, eventHandler);
        return scene;
    }
}
