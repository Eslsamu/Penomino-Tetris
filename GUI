import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.layout.GridPane;
import javafx.scene.text.Text;

public class GUI{
    	
    //create the two text files that contain rowscleared and currentscore
    private Text rowscleared;
    private Text currentscore;
    
    //create Pane board, which is only the board where the game happens
    private Pane board;
    private GridPane mainGrid;
    private BackendGrid backendGrid;
    
    //pane that displays the next block
    private Pane nextBlockPane;
    
    public GUI(BackendGrid backendGrid){
        //use the same BackendGrid from Main from GameCycle
        this.backendGrid = backendGrid;       
    }
    
    public GridPane createGUI(){
        //create a mainGrid where we add:
    	board = new Pane();
        mainGrid = new GridPane();
        nextBlockPane = new Pane();
        
        mainGrid.setMinSize(600,500);
        mainGrid.setPadding(new Insets(0, 0, 10, 20));
        mainGrid.setVgap(5); 
        mainGrid.setHgap(5);
        //here we add the left rectangle containing scores and rules
        mainGrid.add(scoresRule(), 0, 0);
        //middle rectangle with gameBoard
        mainGrid.add(drawGrid(), 1, 0);
        //right rectangle where nextPentomino is displayed
        mainGrid.add(drawNextBlock(), 2, 0);
        mainGrid.getStylesheets().add("petris/stylesheet.css");
        
        return mainGrid;
    } 
    public Parent scoresRule(){
        //creates the grid for scores and rules
        GridPane scoresRule = new GridPane();
        scoresRule.setMinSize(125, 730);
        scoresRule.setPadding(new Insets(0, 0, 0, 0));
        scoresRule.setHgap(5);
        scoresRule.setGridLinesVisible(false);
        //adds scores on the top
        scoresRule.add(score(), 0, 0);
        //adds rules on the bottom
        scoresRule.add(rules(), 0, 1);
        return scoresRule;
    }
    
    public Parent score(){
        //create score gridpane
        GridPane score = new GridPane();
        score.setMinSize(125, 375);
        score.setPadding(new Insets(0, 0, 0, 0));
        score.setGridLinesVisible(false);
        score.setStyle("-fx-border-color: white; -fx-background-color: #9ac6d6; -fx-fill: #DAA520; fx-font-weight: bold; -fx-font-size: 11pt");
        
        Text RowsCleared = new Text(200, 200,  "Rows cleared:");
        RowsCleared.setStyle("-fx-font-size: 12pt; -fx-font-color:red;");
        score.setAlignment(Pos.TOP_CENTER);
        rowscleared = new Text(backendGrid.getRowsCleared() + "");
        rowscleared.setStyle("-fx-fill: #DAA520; -fx-font-size: 11pt;");
        Text Currentscore = new Text("Current score");
        Currentscore.setStyle("-fx-font-size: 12pt; -fx-font-color:red;");
        currentscore = new Text(backendGrid.getScore() + "");
        score.add(RowsCleared, 0, 0);
        score.add(rowscleared, 0, 1);
        score.add(Currentscore, 0, 2);
        score.add(currentscore, 0, 3);
        
        return score;
    }
    public void updateData(){
        //whenever this method is called it will change the rowscleared and currentscore with the latest values taken from BackendGrid
        rowscleared.setText(backendGrid.getRowsCleared()+ "");
        currentscore.setText(backendGrid.getScore()+ "");
    }
    public Parent rules(){
        //gridpane rules
        GridPane rules = new GridPane();
        rules.setMinSize(125, 375);
        rules.setGridLinesVisible(false);
        rules.setAlignment(Pos.TOP_LEFT);
        rules.setStyle("-fx-border-color: white; -fx-border-width: 0 1 1 1; -fx-background-color: #9ac6d6; -fx-fill: #DAA520; fx-font-weight: bold;");
        Text controlsHeader = new Text("Controls");
        controlsHeader.setStyle("-fx-fill: red; -fx-font-size: 12pt");
        Text controls = new Text("Movement: \nleft and right \narrow keys \nRotation: \nup and down \narrow keys \nDrop piece:\nspacebar \n");
        Text rulesHeader = new Text("Rules");
        rulesHeader.setStyle("-fx-fill: red; -fx-font-size: 12pt");
        Text rule = new Text("Earn score by \nclearing lines\nwhen the board \nfills up\nyou lose.\n1 line:  100\n2 lines: 300\n3 lines: 600 \n4 lines: 1000\n5 lines: 1500 ");
        
        rules.add(controlsHeader, 0,1);
        rules.add(controls, 0, 2);
        rules.add(rulesHeader, 0 ,3);
        rules.add(rule, 0, 4);
        
        return rules;
    }
    
    
    public Parent drawNextBlock(){
        nextBlockPane.getChildren().clear();
        
        nextBlockPane.setMinSize(200, 200);
        nextBlockPane.setPadding(new Insets(20, 0, 0, 20));
        
        int[][] nextBlockCoords = backendGrid.getNextBlock().getCoordinates();
        
        for(int i = 0; i < nextBlockCoords[0].length; i++) {
        	Rectangle blockSquare = new Rectangle(50,50);

        	blockSquare.setStroke(Color.BLACK);
        	nextBlockPane.getChildren().add(blockSquare);
        	blockSquare.setTranslateX(nextBlockCoords[0][i]*50);
        	blockSquare.setTranslateY(nextBlockCoords[1][i]*50);
        	blockSquare.setFill(backendGrid.getNextBlock().getColorIndex());
        }
           
        return nextBlockPane;
    }
    
    public Parent drawGrid(){
        //set the initial background, that is going to be constantly updated
    	board.getChildren().clear();
        board.setMinSize(250, 750);
        
        int count = 0;
        Color[][] grid = backendGrid.getGrid();
        //fill board with rectangles representing each coordinate of gridMatrix from BackendGrid
        for(int i = 0; i < grid.length ; i++){
            for(int x = 0; x < grid[0].length; x++){
                    Rectangle rec = new Rectangle(50, 50);
                    //set the color adn other things
                    rec.setFill(grid[i][x]);
                    rec.setStroke(Color.BLACK);
                    rec.setTranslateX(x * 50);
                    rec.setTranslateY(i * 50);
                    board.getChildren().add(count, rec);
                    count++;
            }
        }
        
        int[][] fallingBlockCoords =  backendGrid.getFallingBlock().getCoordinates();
        Color color = backendGrid.getFallingBlock().getColorIndex();
        
        for(int i = 0; i < fallingBlockCoords[0].length; i++) {
        	Rectangle blockSquare = new Rectangle(50,50);
        	
        	board.getChildren().add(blockSquare);
        	blockSquare.setStroke(Color.BLACK);
        	blockSquare.setTranslateX(fallingBlockCoords[0][i]*50);
        	blockSquare.setTranslateY(fallingBlockCoords[1][i]*50);
        	blockSquare.setFill(color);
        } 
               
       return board;
    }
    
    /*public void updatePentomino(){
    
        //updates the rectangles color and position
        //if the game is over the falling pento will be removed from board to avoid bugs
      /*  if(backendGrid.gameOverCheck()){
            board.getChildren().remove(position1);
            board.getChildren().remove(position2);
            board.getChildren().remove(position3);
            board.getChildren().remove(position4);
            board.getChildren().remove(position5);
        }
        
        int[][] fallingBlockCoords =  backendGrid.getFallingBlock().getCoordinates();
        Color color = backendGrid.getFallingBlock().getColorIndex();
        
        for(int i = 0; i < fallingBlockCoords[0].length; i++) {
        	Rectangle blockSquare = new Rectangle(50,50);
        	
        	board.getChildren().add(blockSquare);
        	blockSquare.setStroke(Color.BLACK);
        	blockSquare.setTranslateX(fallingBlockCoords[0][i]*50);
        	blockSquare.setTranslateY(fallingBlockCoords[1][i]*50);
        	blockSquare.setFill(color);
        } 
        
        /*position1.setFill(color);
        position2.setFill(color);
        position3.setFill(color);
        position4.setFill(color);
        position5.setFill(color);
        
        position1.setTranslateY(coordinates[1][0]*50);
        position1.setTranslateX(coordinates[0][0]*50);
        position2.setTranslateY(coordinates[1][1]*50);
        position2.setTranslateX(coordinates[0][1]*50);
        position3.setTranslateY(coordinates[1][2]*50);
        position3.setTranslateX(coordinates[0][2]*50);
        position4.setTranslateY(coordinates[1][3]*50);
        position4.setTranslateX(coordinates[0][3]*50);
        position5.setTranslateY(coordinates[1][4]*50);
        position5.setTranslateX(coordinates[0][4]*50);      
    }*/
    
  /*  public void updateGameBoard(){

        //goes through each coordinate of gridMatrix from backendGrid and creates a new rectangle with the colorindex the gridMatrix returns
            int count = 0;
            Color[][] grid = backendGrid.getGrid();
            for(int i = 0; i < grid.length ; i++){
                for(int x = 0; x < grid[0].length; x++){
                    Rectangle rec = new Rectangle(50, 50);
                    rec.setTranslateX(x * 50);
                    rec.setTranslateY(i * 50);
                    board.getChildren().set(count, rec);
                    rec.setStroke(Color.BLACK);
                    rec.setFill(grid[i][x]);
                    count++;
                }
            }   
    }*/
    
    public Scene getScene(){
        //adds the controls to the scene and creates the scene
        Controlls controls = new Controlls(backendGrid);
        EventHandler eventHandler = controls.setControls();
        Scene scene = new Scene(createGUI());
        scene.addEventFilter(KeyEvent.KEY_PRESSED, eventHandler);
        return scene;
    }
}
